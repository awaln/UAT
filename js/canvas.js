// Generated by CoffeeScript 1.9.1
(function() {
  var CONFIDENCE_THRESHOLD, DATE, DRAWABLE_SHAPES, DRAW_COLOR, ask_user, canvas, ctx, currX, currY, curr_start_time, current_stroke_x, current_stroke_y, current_times, dot_flag, draw, drawing, findxy, flag, prevX, prevY, strokes_x, strokes_y, times, x, y;

  DRAW_COLOR = 'black';

  DATE = new Date;

  strokes_x = [];

  strokes_y = [];

  times = [];

  current_stroke_x = [];

  current_stroke_y = [];

  current_times = [];

  canvas = void 0;

  ctx = void 0;

  flag = false;

  prevX = 0;

  currX = 0;

  prevY = 0;

  currY = 0;

  curr_start_time = 0;

  dot_flag = false;

  x = 'black';

  y = 2;

  drawing = {
    nodes: {},
    loners: [],
    edges: {},
    arrows: [],
    nodelabels: {},
    edgelabels: {}
  };

  this.init = function() {
    var h, w;
    canvas = document.getElementById('can');
    ctx = canvas.getContext('2d');
    w = canvas.width;
    h = canvas.height;
    canvas.addEventListener('mousemove', (function(e) {
      findxy('move', e);
    }), false);
    canvas.addEventListener('mousedown', (function(e) {
      findxy('down', e);
    }), false);
    canvas.addEventListener('mouseup', (function(e) {
      findxy('up', e);
    }), false);
    canvas.addEventListener('mouseout', (function(e) {
      findxy('out', e);
    }), false);
    canvas.addEventListener('touchmove', (function(e) {
      findxy('move', e.changedTouches[0]);
    }), false);
    canvas.addEventListener('touchstart', (function(e) {
      findxy('down', e.changedTouches[0]);
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchend', (function(e) {
      findxy('up', e.changedTouches[0]);
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchleave', (function(e) {
      findxy('out', e.changedTouches[0]);
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchcancel', (function(e) {
      findxy('out', e.changedTouches[0]);
      e.preventDefault();
    }), false);
  };

  draw = function() {
    ctx.beginPath();
    ctx.moveTo(prevX, prevY);
    ctx.lineTo(currX, currY);
    ctx.strokeStyle = x;
    ctx.lineWidth = y;
    ctx.fillStyle = 'white';
    ctx.stroke();
    ctx.closePath();
    current_stroke_x.push(currX);
    current_stroke_y.push(currY);
    current_times.push(new Date().getTime() - curr_start_time);
  };

  findxy = function(res, e) {
    if (res === 'down') {
      prevX = currX;
      prevY = currY;
      currX = e.clientX - canvas.offsetLeft;
      currY = e.clientY - canvas.offsetTop;
      curr_start_time = new Date().getTime();
      flag = true;
      dot_flag = true;
      if (dot_flag) {
        ctx.beginPath();
        ctx.fillStyle = x;
        ctx.fillRect(currX, currY, 2, 2);
        ctx.closePath();
        dot_flag = false;
      }
    }
    if (res === 'up' || res === 'out') {
      flag = false;
      if (current_stroke_x.length > 0) {
        strokes_x.push(current_stroke_x);
        strokes_y.push(current_stroke_y);
        times.push(current_times);
        current_stroke_x = [];
        current_stroke_y = [];
        current_times = [];
      }
    }
    if (res === 'move') {
      if (flag) {
        prevX = currX;
        prevY = currY;
        currX = e.clientX - canvas.offsetLeft;
        currY = e.clientY - canvas.offsetTop;
        draw();
      }
    }
  };

  this.recognize_all = function() {
    var i, j, ref;
    for (i = j = 0, ref = strokes_x.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      drawing = recognize(strokes_x[i], strokes_y[i], times[i], ctx, canvas, drawing);
    }
    drawing = relate(drawing);
    pretty_draw(ctx, canvas, drawing);
    ask_user();
  };

  CONFIDENCE_THRESHOLD = .81;

  ask_user = function() {
    var answers, guess, j, len, node, ref, x_point, y_point;
    ref = Object.keys(drawing.nodes);
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      if (drawing.nodes[node].type["circle"] < CONFIDENCE_THRESHOLD && drawing.nodes[node].type["polygon"] < CONFIDENCE_THRESHOLD) {
        console.log(drawing.nodes[node]);
        pretty_draw(ctx, canvas, drawing);
        x_point = drawing.nodes[node].center_x;
        y_point = drawing.nodes[node].center_y + drawing.nodes[node].radius;
        ctx.beginPath();
        ctx.moveTo(x_point, y_point);
        ctx.lineTo(x_point + 10, y_point + 50);
        ctx.lineTo(x_point - 10, y_point + 50);
        ctx.lineTo(x_point, y_point);
        ctx.closePath();
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.stroke();
        if (drawing.nodes[node].type["circle"] > drawing.nodes[node].type["polygon"]) {
          guess = "<p>I'm not sure what you've drawn here. My best guess is a circle. Is that right?</p>";
          answers = "<button onclick='answer(0)'>yes</button><button onclick='answer(1)'>no</button>";
        } else {
          guess = "<p>I'm not sure what you've drawn here. My best guess is a polygon. Is that right?</p>";
          answers = "<button onclick='answer(1)'>yes</button><button onclick='answer(0)'>no</button>";
        }
        document.getElementById("askbox").innerHTML = guess + answers;
        return;
      }
    }
    return document.getElementById("askbox").innerHTML = "";
  };

  DRAWABLE_SHAPES = ["circle", "polygon"];

  this.answer = function(int) {
    var j, len, node, ref;
    ref = Object.keys(drawing.nodes);
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      console.log(drawing.nodes[node]);
      if (drawing.nodes[node].type["circle"] < CONFIDENCE_THRESHOLD && drawing.nodes[node].type["polygon"] < CONFIDENCE_THRESHOLD) {
        drawing.nodes[node].type[DRAWABLE_SHAPES[int]] = 1;
      }
    }
    pretty_draw(ctx, canvas, drawing);
    return ask_user();
  };

}).call(this);
