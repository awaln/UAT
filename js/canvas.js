// Generated by CoffeeScript 1.9.1
(function() {
  var CONFIDENCE_THRESHOLD, DATE, DRAWABLE_SHAPES, DRAW_COLOR, ask_user, canvas,
    ctx, currX, currY, curr_start_time, current_stroke_x, current_stroke_y, 
    current_times, dot_flag, draw, drawing, findxy, flag, prevX, prevY, 
    strokes_x, strokes_y, times, x, y;

  DRAW_COLOR = 'black';
  DATE = new Date;
  strokes_x = [];
  strokes_y = [];
  times = [];
  current_stroke_x = [];
  current_stroke_y = [];
  current_times = [];
  canvas = void 0;
  ctx = void 0;
  flag = false;
  prevX = 0;
  currX = 0;
  prevY = 0;
  currY = 0;
  curr_start_time = 0;
  dot_flag = false;
  x = 'black';
  y = 2;
  var move_mode = false;
  var held_node = null;
  var grip = null;
  var temp_drawing = {};
  
  drawing = {
    nodes: {},
    loners: [],
    edges: {},
    arrows: [],
    nodelabels: {},
    edgelabels: {}
  };

  this.init = function() {
    var h, w;
    canvas = document.getElementById('can');
    ctx = canvas.getContext('2d');
    w = canvas.width;
    h = canvas.height;
    canvas.addEventListener('mousemove', (function(e) {
      if(move_mode && grip != null){
        move_node(e);
      }
      else {
        findxy('move', e);
      }
    }), false);
    canvas.addEventListener('mousedown', (function(e) {
      if(move_mode){
        highlight(e);
      }
      else {
        findxy('down', e);
      }
    }), false);
    canvas.addEventListener('mouseup', (function(e) {
      if(move_mode){
        drop_node(e, false);
        unhighlight(e);
      }
      else {
        findxy('up', e);
      }
    }), false);
    canvas.addEventListener('mouseout', (function(e) {
      if(move_mode){
        drop_node(e, true);
        unhighlight(e);
      }
      else {
        findxy('out', e);
      }
    }), false);
    canvas.addEventListener('touchmove', (function(e) {
      if(move_mode && grip != null){
        move_node(e.changedTouches[0]);
      }
      else {
        findxy('move', e.changedTouches[0]);
      }
    }), false);
    canvas.addEventListener('touchstart', (function(e) {
      if(move_mode){
        highlight(e.changedTouches[0]);
      }
      else {
        findxy('down', e.changedTouches[0]);
      }
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchend', (function(e) {
      if(move_mode){
        drop_node(e.changedTouches[0], false);
        unhighlight(e.changedTouches[0]);
      }
      else {
        findxy('up', e.changedTouches[0]);
      }
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchleave', (function(e) {
      if(move_mode){
        drop_node(e, true);
        unhighlight(e.changedTouches[0]);
      }
      else {
        findxy('out', e.changedTouches[0]);
      }
      e.preventDefault();
    }), false);
    canvas.addEventListener('touchcancel', (function(e) {
      if(move_mode){
        drop_node(e, true);
        unhighlight(e.changedTouches[0]);
      }
      else {
        findxy('out', e.changedTouches[0]);
      }
      e.preventDefault();
    }), false);
  };

  draw = function() {
    ctx.beginPath();
    ctx.moveTo(prevX, prevY);
    ctx.lineTo(currX, currY);
    ctx.strokeStyle = x;
    ctx.lineWidth = y;
    ctx.fillStyle = 'white';
    ctx.stroke();
    ctx.closePath();
    current_stroke_x.push(currX);
    current_stroke_y.push(currY);
    current_times.push(new Date().getTime() - curr_start_time);
  };

  findxy = function(res, e) {
    if (res === 'down') {
      prevX = currX;
      prevY = currY;
      currX = e.clientX - canvas.offsetLeft;
      currY = e.clientY - canvas.offsetTop;
      curr_start_time = new Date().getTime();
      flag = true;
      dot_flag = true;
      if (dot_flag) {
        ctx.beginPath();
        ctx.fillStyle = x;
        ctx.fillRect(currX, currY, 2, 2);
        ctx.closePath();
        dot_flag = false;
      }
    }
    if (res === 'up' || res === 'out') {
      flag = false;
      if (current_stroke_x.length > 0) {
        strokes_x.push(current_stroke_x);
        strokes_y.push(current_stroke_y);
        times.push(current_times);
        current_stroke_x = [];
        current_stroke_y = [];
        current_times = [];
      }
    }
    if (res === 'move') {
      if (flag) {
        prevX = currX;
        prevY = currY;
        currX = e.clientX - canvas.offsetLeft;
        currY = e.clientY - canvas.offsetTop;
        draw();
      }
    }
  };

  var highlight = function(e){
    // find out if the point lies within a node, highlight that node.
    var actualX = e.clientX - canvas.offsetLeft;
    var actualY = e.clientY - canvas.offsetTop;
    for(var i = 0; i < Object.keys(drawing.nodes).length; i++){
      if(point_within_node(drawing.nodes[i], actualX, actualY)){
        draw_node(ctx, drawing.nodes[i], 'blue');
        held_node = drawing.nodes[i];
        grip = [actualX, actualY];
        return;
      }
    }
  }

  var unhighlight = function(e){
    // find out if the point lies within a node, highlight that node.
    var actualX = e.clientX - canvas.offsetLeft;
    var actualY = e.clientY - canvas.offsetTop;
    for(var i = 0; i < Object.keys(drawing.nodes).length; i++){
      if(point_within_node(drawing.nodes[i], actualX, actualY)){
        draw_node(ctx, drawing.nodes[i], 'black');
        held_node = null;
        grip = null;
        return;
      }
    }
  }

  var move_node = function(e){
    var actualX = e.clientX - canvas.offsetLeft;
    var actualY = e.clientY - canvas.offsetTop;
    var deltaX = actualX - grip[0];
    var deltaY = actualY - grip[1];
    for(var i = 0; i < Object.keys(drawing.nodes).length; i++){
      if(point_within_node(drawing.nodes[i], actualX, actualY)){
        drawing.nodes[i].center_x += deltaX;
        drawing.nodes[i].center_y += deltaY;
        for(var corner = 0; corner < drawing.nodes[i].corners.length; corner++){
          drawing.nodes[i].corners[corner].x += deltaX;
          drawing.nodes[i].corners[corner].y += deltaY;
        }
        pretty_draw(ctx, canvas, drawing);
        draw_node(ctx, drawing.nodes[i], 'blue');
        grip = [actualX, actualY];
        return;
      }
    }
  }

  var drop_node = function(e, abort){
    var actualX = e.clientX - canvas.offsetLeft;
    var actualY = e.clientY - canvas.offsetTop;
    for(var i = 0; i < Object.keys(drawing.nodes).length; i++){
      if(point_within_node(drawing.nodes[i], actualX, actualY)){
        if(abort){
          drawing.nodes[i] = held_node;
        }
        pretty_draw(ctx, canvas, drawing);
        draw_node(ctx, drawing.nodes[i], 'blue');
        return;
      }
    }
  }

  this.recognize_all = function() {
    var i, j, ref;
    for (i = j = 0, ref = strokes_x.length; 0 <= ref ? j < ref : j > ref; i = 0
        <= ref ? ++j : --j) {
      drawing = recognize(strokes_x[i], strokes_y[i], times[i], ctx, canvas,
        drawing);
    }
    strokes_x = [];
    strokes_y = [];
    times = []
    drawing = relate(drawing);
    pretty_draw(ctx, canvas, drawing);
    this.try_organizer = true;
    this.try_binary_tree = true;
    ask_user();
  };

  CONFIDENCE_THRESHOLD = .81;
  ask_user = function() {
    var nodes = ask_user_nodes();
    if(nodes == 0 && this.try_binary_tree) {
      var binary = ask_user_binary_tree();
    }
    else if (nodes == 0 && this.try_organizer) {
      var organize = ask_user_organize();
    }
  }

  ask_user_nodes = function() {
    var answers, guess, j, len, node, ref, x_point, y_point;
    ref = Object.keys(drawing.nodes);
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      if (!drawing.nodes[node].known) {
        pretty_draw(ctx, canvas, drawing);
        x_point = drawing.nodes[node].center_x;
        y_point = drawing.nodes[node].center_y + drawing.nodes[node].radius;
        ctx.beginPath();
        ctx.moveTo(x_point, y_point);
        ctx.lineTo(x_point + 10, y_point + 50);
        ctx.lineTo(x_point - 10, y_point + 50);
        ctx.lineTo(x_point, y_point);
        ctx.closePath();
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.stroke();
        if (drawing.nodes[node].type["circle"] >=
            drawing.nodes[node].type["polygon"]) {
          guess = "<p>I'm not sure what you've drawn here. My best guess is a \
                  circle. Is that right?</p>";
          answers = "<button onclick='answer_nodes(0)'>yes</button><button \
                    onclick='answer_nodes(1)'>no</button>";
        } else {
          guess = "<p>I'm not sure what you've drawn here. My best guess is a \
                  polygon. Is that right?</p>";
          answers = "<button onclick='answer_nodes(1)'>yes</button><button \
                    onclick='answer_nodes(0)'>no</button>";
        }
        document.getElementById("askbox").innerHTML = guess + answers;
        return 1;
      }
    }
    document.getElementById("askbox").innerHTML = "";
    return 0;
  };

  ask_user_organize = function(){
    this.try_organizer = false;
    var longest = longest_path(drawing);
    if(longest.length < 2){
      document.getElementById("askbox").innerHTML = "";
      return 0;
    }
    // if they will fit vertically, do so.
    // say, buffer of 50 pixels so they don't hit each other
    BUFFER = 20;
    var height = 0;
    for(i in longest){
      height = height + BUFFER + drawing.nodes[parseInt(i)].radius*2;
    }
    // TODO: Canvas height hard-coded.
    if(height > 390){
      document.getElementById("askbox").innerHTML = "";
      return 0;
    }
    // it'll fit.
    temp_drawing = $.extend(true, {}, drawing);
    // set all nodes in path to same x, different y.
    height = 10;
    for(i in longest){
      height = height + drawing.nodes[parseInt(i)].radius + BUFFER;
      var deltaX = 200 - drawing.nodes[i].center_x;
      var deltaY = height - drawing.nodes[i].center_y;
      drawing.nodes[i].center_x = 200;
      drawing.nodes[i].center_y = height;
      for(var corner = 0; corner < drawing.nodes[i].corners.length; corner++){
        drawing.nodes[i].corners[corner].x += deltaX;
        drawing.nodes[i].corners[corner].y += deltaY;
      }
      height = height + drawing.nodes[i].radius;
    }
    pretty_draw(ctx, canvas, drawing);
    guess = "<p>I found a way to reorganize your graph. Keep changes?</p>";
    answers = "<button onclick='answer_organize(1)'>yes</button><button \
                    onclick='answer_organize(0)'>no</button>";
    document.getElementById("askbox").innerHTML = guess + answers;
    return 1;
  }

  this.ask_user_binary_tree = function(){
    this.try_binary_tree = false;
    var stuff = binary_tree(drawing);
    var tops = stuff[0];
    var adjacency = stuff[1];
    console.log("BINARY TREE:");
    console.log(tops, adjacency);
    // we now have potential tops of binary trees. Pick the first one for now.
    var top = tops[0];
    temp_drawing = $.extend(true, {}, drawing);
    BUFFER = 20;
    depth = 0;
    var level = [top];
    while(level.length > 0){
      // take all the nodes in the level, generate next level IN ORDER.
      // also find the largest node in the level and set depth appropriately.
      var next_level = [];
      var max_diameter = 0;
      for(var i = 0; i < level.length; i++){
        var item = level[i];
        max_diameter = Math.max(max_diameter, drawing.nodes[item].radius*2);
        if(adjacency[item] != undefined) {
          for (var j = 0; j < adjacency[item].length; j++) {
            next_level.push(adjacency[item][j]);
          }
        }
      }
      console.log("LEVEL:");
      console.log(level);
      // set up level
      depth = depth + BUFFER + max_diameter;
      spacing = (400-max_diameter)/(level.length);
      left = max_diameter/2;
      // center top node
      if(level[0] === top){
        left = 200;
      }
      for(var i = 0; i < level.length; i++){
        console.log("PLACING " + level[i]);
        console.log(depth, spacing, left);
        var item = level[i];
        var deltaX = left - drawing.nodes[item].center_x;
        var deltaY = depth - drawing.nodes[item].radius - drawing.nodes[item].center_y;
        drawing.nodes[item].center_x = left;
        drawing.nodes[item].center_y = depth - drawing.nodes[item].radius;
        for(var corner = 0; corner < drawing.nodes[item].corners.length; corner++){
          drawing.nodes[item].corners[corner].x += deltaX;
          drawing.nodes[item].corners[corner].y += deltaY;
        }
        left = left + spacing;
      }
      // next level
      level = next_level;
    }
    console.log("CLEANED: ");
    console.log(drawing);
    pretty_draw(ctx, canvas, drawing);
    guess = "<p>I found a way to reorganize your graph. Keep changes?</p>";
    answers = "<button onclick='answer_organize(1)'>yes</button><button \
                    onclick='answer_organize(0)'>no</button>";
    document.getElementById("askbox").innerHTML = guess + answers;
    return 1;
  }

  this.answer_organize = function(int){
    if(int == 0){
      drawing = temp_drawing;
      pretty_draw(ctx, canvas, drawing);
    }
    temp_drawing = null;
    document.getElementById("askbox").innerHTML = "";
    return ask_user();
  }

  DRAWABLE_SHAPES = ["circle", "polygon"];

  this.answer_nodes = function(int) {
    var j, len, node, ref;
    ref = Object.keys(drawing.nodes);
    for (j = 0, len = ref.length; j < len; j++) {
      node = ref[j];
      if (!drawing.nodes[node].known) {
        drawing.nodes[node].type[DRAWABLE_SHAPES[int]] = 1;
        drawing.nodes[node].known = true;
        pretty_draw(ctx, canvas, drawing);
        return ask_user();
      }
    }
    pretty_draw(ctx, canvas, drawing);
    return ask_user();
  };

  this.move_toggle = function() {
    if(move_mode){
      document.getElementById("move_toggle").innerHTML = "Move Mode";
      move_mode = false;
    }
    else {
      document.getElementById("move_toggle").innerHTML = "Draw Mode";
      move_mode = true;
    }
  }

}).call(this);
